<html lang="zh-CN">

<body>

  <script>
    let bleDevice;
    let gattServer;
    let Theservice;
    let epdService;
    let epochCharacter;

    async function sleep(ms) {
      await new Promise(resolve => setTimeout(resolve, ms));
    }

    async function doConnect() {
      if (gattServer != null && gattServer.connected) {
        if (bleDevice != null && bleDevice.gatt.connected)
          bleDevice.gatt.disconnect();
      }
      else {
        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: ['C26_'] }],
          optionalServices: [
            0xfff0,
          ],
          //acceptAllDevices: true 
        });
        await bleDevice.addEventListener('gattserverdisconnected', disconnect);
        await connect();
      }
    }

    async function connect() {
      if (epochCharacter == null) {
        info("Connect to " + bleDevice.name)
        gattServer = await bleDevice.gatt.connect();
        info('> Found GATT server');
        epdService = await gattServer.getPrimaryService(0xfff0);
        info('> Found EPD service');
        epochCharacter = await epdService.getCharacteristic(0xfff1);
        document.getElementById("btnConnect").innerHTML = 'Disconnect';
        document.getElementById('etagFn').style.visibility = '';
      }
    }

    function disconnect() {
      bleDevice = null;
      epdService = null;
      epochCharacter = null;
      info('Disconnected.');

      document.getElementById("btnConnect").innerHTML = 'Connect';
      document.getElementById('etagFn').style.visibility = 'hidden';
    }

    async function doSetTime() {
      var epoch = Date.now() / 1000 | 0;
      var buf = new ArrayBuffer(4);
      var arr = new Uint32Array(buf);
      arr[0] = epoch;
      await epochCharacter.writeValueWithResponse(arr);
      info("Write unix epoch: " + epoch);
    }

    async function doReadEtag() {
      var host_epoch = Date.now() / 1000 | 0;

      // read current time
      var chr = await epdService.getCharacteristic(0xfff1);
      var epoch = (await chr.readValue()).getUint32(0, 1);

      // read time zone
      var chr = await epdService.getCharacteristic(0xfff2);
      var tz_min = (await chr.readValue()).getInt32(0, 1);
      info(`# host time: ${host_epoch}, diff (${epoch - host_epoch}) seconds.`);
      info(`# etag time: ${epoch}, tz: ${tz_min} minutes of UTC.`);

      // battery
      var chr = await epdService.getCharacteristic(0xfff3);
      var batt = (await chr.readValue()).getUint16(0, 1);

      // Temperature
      var chr = await epdService.getCharacteristic(0xfff4);
      var temp = (await chr.readValue()).getInt8(0, 1);
      info(`# etag sensor: battery(${batt}mv), temperature(${temp}'C). `);

      // RTC Collaborate
      var chr = await epdService.getCharacteristic(0xfff5);
      var rtc_collab = (await chr.readValue()).getInt8(0, 1);
      info(`# rtc collab: ${rtc_collab} every 1 second.`);
    }

    async function doRtcCollab() {
      var col = prompt("对 32.768kHz 晶振补偿频漂，走时快补偿负数，走时慢补偿正数。可选范围 (-3 ~ 3)", 0);
      if (col == null || col < -3 || col > 3) return;
      var chr = await epdService.getCharacteristic(0xfff5);
      var buf = new ArrayBuffer(1);
      var arr = new Int8Array(buf);
      arr[0] = parseInt(col);
      await chr.writeValueWithResponse(arr);
      info(`write RTC collabration: ${col}`);
    }

    async function doTest() {
      var chr = await epdService.getCharacteristic(0xfffe);
      var buf = new ArrayBuffer(62);
      var arr = new Int8Array(buf);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = i % 8;
      }
      await chr.writeValueWithResponse(arr);
      info(`> write ${arr.length} bytes.`)
      //var out = await chr.readValue();
      //console.log(out);
    }

    async function doCmd(cmd, data) {
      var chr = await epdService.getCharacteristic(0xfffe);
      if (cmd == 'clr') {
        await chr.writeValueWithResponse(Uint8Array.from([0x01]));
        info(`> clear`);
      } else if (cmd == 'mode') {
        await chr.writeValueWithResponse(Uint8Array.from([0x02, 0x01]));
        info(`> mode 1`);
      } else if (cmd == 'buf') {
        for (var i = 0; i < data.length; i += 60) {
          let arr = [(i == 0 ? 0x03 : 0x04)];
          arr.push(...data.slice(i, i + 60));
          //console.log(arr);
          await chr.writeValueWithResponse(Uint8Array.from(arr));
          //info(`> buf at ${i} size ${arr.length}`)
        }
        info('> buf done.')
      } else if (cmd == 'bw') {
        // write to bw ram
        await chr.writeValueWithResponse(Uint8Array.from([0x05]));
        info(`> bw`);
      } else if (cmd == 'red') {
        // write to bw ram
        await chr.writeValueWithResponse(Uint8Array.from([0x06]));
        info(`> red`);
 
      } else if (cmd == 'dp') {
        // show
        await chr.writeValueWithResponse(Uint8Array.from([0x07]));
        info(`> dp`);
      }
    }

    let ram_bw = [];
    let ram_red = [];
    function doImageGrey(type) {
      const canvas = document.getElementById('canvas');
      ram_bw = canvas2grey8(canvas, 'bw');
      ram_red = canvas2grey8(canvas, 'red');
    }

    var step = 0;
    async function doUploadImage(type) {
      doImageGrey();
      for (var i=0; i<8; i++) {
        await doCmd('mode');
        await sleep(2000);
        await doUploadImage3('bw');
        await doUploadImage3('red');
        await doCmd('dp');
        await sleep(8000);
        step ++;
      }
      step = 0;
      info('> Upload done.')
   }
    async function doUploadImage2(type='bw') {
      //const canvas = document.getElementById('canvas');
      //var arr = canvas2bytes(canvas, type=type);
      var arr = new Uint8Array(296*128/8);
      arr.fill(type=='bw'?0xff:0x00);
      for (var i=0; i<128/8; i++) { // y
        if (parseInt(i/2) > step) break;
        for (var j=0; j<64; j++) {  // x
          arr[i*296+j+(type=='bw'?0:64)] = type=='bw'?0x00:0xff; 
        }
      }
      await doCmd('buf', arr);
      await doCmd(type)
      console.log(`step ${step}`);
    }

    async function doUploadImage3(type='bw') {
      var ram = type=='bw'?ram_bw:ram_red;

      // grey byte to bit
      var arr = [];
      var buffer = [];
      for (var x=0; x<ram.length; x++) {
        const n = ram[x] > step ? 1 : 0;
        if (type == 'bw') {
            buffer.push(n?0:1);
        } else {
            buffer.push(n?1:0);
        }

        if (buffer.length == 8) {
          arr.push(parseInt(buffer.join(''), 2));
          buffer = [];
        }
      }
     
      info(`> write ram ${type} size ${arr.length}, step ${step}`);
      console.log(arr);
      await doCmd('buf', arr);
      await doCmd(type)
    }




    function info(logTXT) {
      var today = new Date();
      var time = ("0" + today.getHours()).slice(-2) + ":" + ("0" + today.getMinutes()).slice(-2) + ":" + ("0" + today.getSeconds()).slice(-2) + " : ";
      document.getElementById("log").innerHTML += time + logTXT + '<br>';
      console.log(time + logTXT);
      while ((document.getElementById("log").innerHTML.match(/<br>/g) || []).length > 10) {
        var logs_br_position = document.getElementById("log").innerHTML.search("<br>");
        document.getElementById("log").innerHTML = document.getElementById("log").innerHTML.substring(logs_br_position + 4);
      }
    }

    async function load_image() {
      const image_file = document.getElementById('image_file');
      if (image_file.files.length > 0) {
        const file = image_file.files[0];

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        const image = new Image();
        image.src = URL.createObjectURL(file);
        image.onload = function (event) {
          URL.revokeObjectURL(this.src);
          ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
          //convert_dithering()
        }
      }
    }

    function get_position(canvas, x, y) {
      let rect = canvas.getBoundingClientRect()
      return {
        x: x - rect.left * (canvas.width / rect.width),
        y: y - rect.top * (canvas.height / rect.height)
      }
    }

    function clear_canvas() {
      if (confirm('确认清除屏幕?')) {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function canvas2bytes(canvas, type = 'bw') {
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const arr = [];
      let buffer = [];

      for (let y = 0; y < canvas.height; y += 8) {
        for (let x = 0; x < canvas.width; x++) {
          for (let a = 0; a < 8; a++) {
            const i = (canvas.width * (y + a) + x) * 4;
            if (type !== 'red') {
              // 1 for white, 0 for black
              // black : 0, 0, 0
              buffer.push(imageData.data[i] === 0 && imageData.data[i + 1] === 0 && imageData.data[i + 2] === 0 ? 0 : 1);
            } else {
              // 1 for red, 0 for white
              buffer.push(imageData.data[i] > 0 && imageData.data[i + 1] === 0 && imageData.data[i + 2] === 0 ? 1 : 0);
            }
          }
          arr.push(parseInt(buffer.join(''), 2));
          buffer = [];
        }
      }
      return arr;
    }

    function canvas2grey8(canvas, type = 'bw') {
      // each px = 4bit black + 4bit red.
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const arr = [];
      let buffer = [];

      for (let y = 0; y < canvas.height; y += 8) {
        for (let x = 0; x < canvas.width; x++) {
          for (let a = 0; a < 8; a++) {
            const i = (canvas.width * (y + a) + x) * 4;
            const R = imageData.data[i];
            const G = imageData.data[i+1];
            const B = imageData.data[i+2];
            
            let grey = 0;  // white
            if (R == 255 && G != 255 && B != 255) { // red
              grey = (type == 'bw') ? 0 : (510+62-G-B)>>6;
            } else { // gray
              grey = (type == 'bw') ? (255+31-R)>>5 : 0;
            }
            arr.push(grey);
          }
        }
      }
      return arr;
    }

    const bwrPalette = [
      [0, 0, 0, 255],
      [255, 255, 255, 255],
      [255, 0, 0, 255]
    ]

    const bwPalette = [
      [0, 0, 0, 255],
      [255, 255, 255, 255],
    ]

    function getColorDistance(rgba1, rgba2) {
      const [r1, b1, g1] = rgba1;
      const [r2, b2, g2] = rgba2;

      const rm = (r1 + r2) / 2;

      const r = r1 - r2;
      const g = g1 - g2;
      const b = b1 - b2;

      return Math.sqrt((2 + rm / 256) * r * r + 4 * g * g + (2 + (255 - rm) / 256) * b * b);
    }

    function getNearColor(pixel, palette) {
      let minDistance = 255 * 255 * 3 + 1;
      let paletteIndex = 0;

      for (let i = 0; i < palette.length; i++) {
        const targetColor = palette[i];
        const distance = getColorDistance(pixel, targetColor);
        if (distance < minDistance) {
          minDistance = distance;
          paletteIndex = i;
        }
      }

      return palette[paletteIndex];
    }

    function getNearColorV2(color, palette) {
      let minDistanceSquared = 255 * 255 + 255 * 255 + 255 * 255 + 1;

      let bestIndex = 0;
      for (let i = 0; i < palette.length; i++) {
        let rdiff = (color[0] & 0xff) - (palette[i][0] & 0xff);
        let gdiff = (color[1] & 0xff) - (palette[i][1] & 0xff);
        let bdiff = (color[2] & 0xff) - (palette[i][2] & 0xff);
        let distanceSquared = rdiff * rdiff + gdiff * gdiff + bdiff * bdiff;
        if (distanceSquared < minDistanceSquared) {
          minDistanceSquared = distanceSquared;
          bestIndex = i;
        }
      }
      return palette[bestIndex];

    }

    function updatePixel(imageData, index, color) {
      imageData[index] = color[0];
      imageData[index + 1] = color[1];
      imageData[index + 2] = color[2];
      imageData[index + 3] = color[3];
    }

    function getColorErr(color1, color2, rate) {
      const res = [];
      for (let i = 0; i < 3; i++) {
        res.push(Math.floor((color1[i] - color2[i]) / rate));
      }
      return res;
    }

    function updatePixelErr(imageData, index, err, rate) {
      imageData[index] += err[0] * rate;
      imageData[index + 1] += err[1] * rate;
      imageData[index + 2] += err[2] * rate;
    }

    function ditheringCanvasByPalette(canvas, palette, type) {
      palette = palette || bwrPalette;

      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const w = imageData.width;

      for (let currentPixel = 0; currentPixel <= imageData.data.length; currentPixel += 4) {
        const newColor = getNearColorV2(imageData.data.slice(currentPixel, currentPixel + 4), palette);

        if (type === "bwr_floydsteinberg") {
          const err = getColorErr(imageData.data.slice(currentPixel, currentPixel + 4), newColor, 16);

          updatePixel(imageData.data, currentPixel, newColor);
          updatePixelErr(imageData.data, currentPixel + 4, err, 7);
          updatePixelErr(imageData.data, currentPixel + 4 * w - 4, err, 3);
          updatePixelErr(imageData.data, currentPixel + 4 * w, err, 5);
          updatePixelErr(imageData.data, currentPixel + 4 * w + 4, err, 1);
        } else {
          // Atkinson
          const err = getColorErr(imageData.data.slice(currentPixel, currentPixel + 4), newColor, 8);

          updatePixel(imageData.data, currentPixel, newColor);
          updatePixelErr(imageData.data, currentPixel + 4, err, 1);
          updatePixelErr(imageData.data, currentPixel + 8, err, 1);
          updatePixelErr(imageData.data, currentPixel + 4 * w - 4, err, 1);
          updatePixelErr(imageData.data, currentPixel + 4 * w, err, 1);
          updatePixelErr(imageData.data, currentPixel + 4 * w + 4, err, 1);
          updatePixelErr(imageData.data, currentPixel + 8 * w, err, 1);
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    function dither() {
      const canvas = document.getElementById('canvas');
			const mode = document.getElementById('dithering').value;
      ditheringCanvasByPalette(canvas, bwrPalette, mode);
    }

    document.body.onload = () => {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let is_allow_drawing = false;
      let is_allow_move_editor = false;
      const image_mode = document.getElementById('canvas-mode');
      const paint_size = document.getElementById('paint-size');
      const paint_color = document.getElementById('paint-color');
      const editor = document.getElementById('edit-font');
      const font = document.getElementById('font');
      //document.getElementById('dithering').value = 'bwr_Atkinson';
      image_mode.value = 'paint';
      paint_color.value = 'black';
      font.value = '黑体';

      editor.onmousemove = function (e) {
        editor.style.fontSize = `${paint_size.value * 10}px`;
        editor.style.color = paint_color.value;
        editor.style.fontFamily = font.value;
        editor.style.fontWeight = 'bold';

        if (is_allow_move_editor) {
          const { x, y } = get_position(canvas, e.clientX, e.clientY);
          if (x < 0 || y < 0 || x > canvas.width || y > canvas.height) {
            return;
          }

          editor.style.left = `${e.clientX - 20}px`;
          editor.style.top = `${e.clientY - 20}px`;

        }
      }

      editor.onmousedown = function (e) {
        is_allow_move_editor = true;
      }

      editor.onmouseup = function (e) {
        is_allow_move_editor = false;
      }

      document.getElementById('update-text').onclick = function () {
        if (!editor.value.length) {
          alert('请先输入文字');
          return;
        }
        editor.style.display = 'none';
        ctx.beginPath();
        ctx.font = `bold ${paint_size.value * 10}px ${font.value}`;
        ctx.fillStyle = paint_color.value;
        const { x, y } = get_position(canvas, parseInt(editor.style.left), parseInt(editor.style.top) + paint_size.value * 10);

        ctx.fillText(editor.value, x, y);
      }

      image_mode.onchange = function (e) {
        if (image_mode.value === 'font') {
          document.getElementById('update-text').style.display = 'inline-block';
          document.getElementById('font').style.display = 'inline-block';

          editor.style.display = 'block';
          editor.style.left = `${e.clientX}px`;
          editor.style.top = `${e.clientY}px`;
          return;
        }
        document.getElementById('update-text').style.display = 'none';
        document.getElementById('font').style.display = 'none';
        editor.style.display = 'none';
      }

      paint_size.onchange = function () {
        if (image_mode.value === 'font') {
          editor.style.fontSize = `${paint_size.value * 10}px`;
        }
      }

      paint_color.onchange = function () {
        if (image_mode.value === 'font') {
          editor.style.color = paint_color.value;
        }
      }

      font.onchange = function () {
        if (image_mode.value === 'font') {
          editor.style.fontFamily = font.value;
        }
      }

      canvas.onmousedown = function (e) {
        let ele = get_position(canvas, e.clientX, e.clientY)
        let { x, y } = ele

        switch (image_mode.value) {
          case 'paint':
            is_allow_drawing = true;
            ctx.beginPath();
            ctx.moveTo(x, y);
            break;
          case 'font':
            editor.style.display = 'block';
            editor.style.left = `${e.clientX}px`;
            editor.style.top = `${e.clientY}px`;
            editor.style.fontSize = `${paint_size.value * 10}px`;
            editor.style.color = paint_color.value;
            editor.style.fontFamily = font.value;
            editor.style.fontWeight = 'bold';

            break
          default:
            break;
        }
      };

      canvas.onmousemove = (e) => {
        let ele = get_position(canvas, e.clientX, e.clientY)
        let { x, y } = ele;
        switch (image_mode.value) {
          case 'paint':
            if (is_allow_drawing) {
              ctx.lineWidth = paint_size.value;
              ctx.strokeStyle = paint_color.value;
              ctx.lineTo(x, y);
              ctx.stroke();
            }
            break;
          case 'font':
            break;

          default:
            break;
        }
      }

      canvas.onmouseup = function () {
        switch (image_mode.value) {
          case 'paint':
            is_allow_drawing = false;
            break;

          case 'font':
            editor.focus();
            is_allow_move_editor = false;
            break;

          default:
            break;
        }
      }

      canvas.onmouseleave = function () {
        if (image_mode.value === 'paint') {
          is_allow_drawing = false;
        }
      }
    }
  </script>

  <p>
    <label> Choose </label>
    <button id="btnConnect" type="button" onclick="doConnect()">Connect</button>
  </p>
  <p id="etagFn" style="visibility:hidden;">
    <button id="btnReadEtag" type="button" onclick="doReadEtag()">ReadEtag</button>
    <button id="btnSetTime" type="button" onclick="doSetTime()">SetTime</button>
    <button id="btnRtcCollab" type="button" onclick="doRtcCollab()">RtcCollab</button>
    <button id="btnTest" type="button" onclick="doTest()">Test</button>
  </p>
  <p>
    <button type="button" onclick="doCmd('clr')">CLR</button>
    <button type="button" onclick="doCmd('mode')">MODE</button>
    <button type="button" onclick="doCmd('bw')">BW</button>
    <button type="button" onclick="doCmd('red')">RED</button>
    <button type="button" onclick="doCmd('dp')">DP</button>
  </p>
  <div id="canvas-box">
    <input type="file" id="image_file" onchange="load_image()" accept=".png,.jpg,.bmp,.webp,.gif">
    <div id="tool-box">
      模式：
      <select id="canvas-mode">
        <option value="paint">画笔</option>
        <option value="font" title="输入完成后 点击：保存文本框">输入文字</option>
      </select>
      画笔/文字大小：
      <input type="number" max="13" min="1" step="1" value="3" id="paint-size">
      画笔颜色：
      <select id="paint-color">
        <option value="red">红色</option>
        <option value="white">白色</option>
        <option value="black">黑色</option>
      </select>

      <select id="font" title="字体" style="display: none;">
        <option value="微软雅黑">微软雅黑</option>
        <option value="黑体">黑体</option>
        <option value="仿宋">仿宋</option>
        <option value="宋体">宋体</option>
        <option value="楷体_GB2312">楷体_GB2312</option>
        <option value="华文行楷">华文行楷</option>
      </select>
      <button id="update-text" style="display: none">保存文本框</button>
      <button onclick="clear_canvas()">清屏</button>

      <br>
	抖动算法：
	<select id="dithering" title="抖动算法">
		<optgroup label="黑白红多色">
			<option value="bwr_floydsteinberg">黑白红floydsteinberg</option>
			<option value="bwr_Atkinson">黑白红Atkinson</option>
		</optgroup>
	</select>
      <button onclick="dither()">Dithering</button>
    </div>
    <input id="edit-font"
      style="max-width: 296px; position: absolute; border: black solid 1px;background-color: rgba(0,0,0,0);display: none;overflow: auto" />
    <canvas id="canvas" width="296" height="128" style="border: black solid 1px;"></canvas>
    <br>
    <button onclick="doUploadImage('bw')">Upload</button>
    <br>
  </div>

  <p>
  <div id="log">
    CC2640R2-ETAG Webtool. <br />
  </div>
  </p>
</body>

</html>