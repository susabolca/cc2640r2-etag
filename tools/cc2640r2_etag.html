<html lang="zh-CN">

<body>

  <script>
    let bleDevice;
    let gattServer;
    let Theservice;
    let epdService;
    let epochCharacter;

    async function sleep(ms) {
      await new Promise(resolve => setTimeout(resolve, ms));
    }

    async function doConnect() {
      if (gattServer != null && gattServer.connected) {
        if (bleDevice != null && bleDevice.gatt.connected)
          bleDevice.gatt.disconnect();
      }
      else {
        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: ['C26_'] }],
          optionalServices: [
            0xfff0,
          ],
          //acceptAllDevices: true 
        });
        await bleDevice.addEventListener('gattserverdisconnected', disconnect);
        await connect();
      }
    }

    async function connect() {
      if (epochCharacter == null) {
        info("Connect to " + bleDevice.name)
        gattServer = await bleDevice.gatt.connect();
        info('> Found GATT server');
        epdService = await gattServer.getPrimaryService(0xfff0);
        info('> Found EPD service');
        epochCharacter = await epdService.getCharacteristic(0xfff1);
        document.getElementById("btnConnect").innerHTML = 'Disconnect';
        document.getElementById('etagFn').style.visibility = '';
      }
    }

    function disconnect() {
      bleDevice = null;
      epdService = null;
      epochCharacter = null;
      info('Disconnected.');

      document.getElementById("btnConnect").innerHTML = 'Connect';
      document.getElementById('etagFn').style.visibility = 'hidden';
    }

    async function doSetTime() {
      var epoch = Date.now() / 1000 | 0;
      var buf = new ArrayBuffer(4);
      var arr = new Uint32Array(buf);
      arr[0] = epoch;
      await epochCharacter.writeValueWithResponse(arr);
      info("Write unix epoch: " + epoch);
    }

    async function doReadEtag() {
      var host_epoch = Date.now() / 1000 | 0;

      // read current time
      var chr = await epdService.getCharacteristic(0xfff1);
      var epoch = (await chr.readValue()).getUint32(0, 1);

      // read time zone
      var chr = await epdService.getCharacteristic(0xfff2);
      var tz_min = (await chr.readValue()).getInt32(0, 1);
      info(`# host time: ${host_epoch}, diff (${epoch - host_epoch}) seconds.`);
      info(`# etag time: ${epoch}, tz: ${tz_min} minutes of UTC.`);

      // battery
      var chr = await epdService.getCharacteristic(0xfff3);
      var batt = (await chr.readValue()).getUint16(0, 1);

      // Temperature
      var chr = await epdService.getCharacteristic(0xfff4);
      var temp = (await chr.readValue()).getInt8(0, 1);
      info(`# etag sensor: battery(${batt}mv), temperature(${temp}'C). `);

      // RTC Collaborate
      var chr = await epdService.getCharacteristic(0xfff5);
      var rtc_collab = (await chr.readValue()).getInt8(0, 1);
      info(`# rtc collab: ${rtc_collab} every 1 second.`);
    }

    async function doRtcCollab() {
      var col = prompt("对 32.768kHz 晶振补偿频漂，走时快补偿负数，走时慢补偿正数。可选范围 (-3 ~ 3)", 0);
      if (col == null || col < -3 || col > 3) return;
      var chr = await epdService.getCharacteristic(0xfff5);
      var buf = new ArrayBuffer(1);
      var arr = new Int8Array(buf);
      arr[0] = parseInt(col);
      await chr.writeValueWithResponse(arr);
      info(`write RTC collabration: ${col}`);
    }

    async function doTest() {
      var chr = await epdService.getCharacteristic(0xfffe);
      var buf = new ArrayBuffer(62);
      var arr = new Int8Array(buf);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = i % 8;
      }
      await chr.writeValueWithResponse(arr);
      info(`> write ${arr.length} bytes.`)
      //var out = await chr.readValue();
      //console.log(out);
    }

    async function doCmd(cmd, data) {
      var chr = await epdService.getCharacteristic(0xfffe);
      if (cmd == 'clr') {
        await chr.writeValueWithResponse(Uint8Array.from([0x01]));
        info(`> clear`);
      } else if (cmd == 'mode') {
        await chr.writeValueWithResponse(Uint8Array.from([0x02, 0x01]));
        info(`> mode 1`);
      } else if (cmd == 'buf') {
        for (var i = 0; i < data.length; i += 60) {
          let arr = [(i == 0 ? 0x03 : 0x04)];
          arr.push(...data.slice(i, i + 60));
          //console.log(arr);
          await chr.writeValueWithResponse(Uint8Array.from(arr));
          //info(`> buf at ${i} size ${arr.length}`)
        }
        info('> buf done.')
      } else if (cmd == 'bw') {
        // write to bw ram
        await chr.writeValueWithResponse(Uint8Array.from([0x05]));
        info(`> bw`);
      } else if (cmd == 'red') {
        // write to bw ram
        await chr.writeValueWithResponse(Uint8Array.from([0x06]));
        info(`> red`);
 
      } else if (cmd == 'dp') {
        // show
        await chr.writeValueWithResponse(Uint8Array.from([0x07]));
        info(`> dp`);
      }
    }

    let ram_bw = [];
    let ram_red = [];
    function doImageGrey(type) {
      const canvas = document.getElementById('canvas');
      ram_bw = canvas2grey8(canvas, 'bw');
      ram_red = canvas2grey8(canvas, 'red');
    }

    var step = 0;
    async function doUploadImage(type) {
      doImageGrey();
      for (var i=0; i<8; i++) {
        await doCmd('mode');
        await sleep(2000);
        await doUploadImage3('bw');
        await doUploadImage3('red');
        await doCmd('dp');
        await sleep(8000);
        step ++;
      }
      step = 0;
      info('> Upload done.')
   }
    async function doUploadImage2(type='bw') {
      //const canvas = document.getElementById('canvas');
      //var arr = canvas2bytes(canvas, type=type);
      var arr = new Uint8Array(296*128/8);
      arr.fill(type=='bw'?0xff:0x00);
      for (var i=0; i<128/8; i++) { // y
        if (parseInt(i/2) > step) break;
        for (var j=0; j<64; j++) {  // x
          arr[i*296+j+(type=='bw'?0:64)] = type=='bw'?0x00:0xff; 
        }
      }
      await doCmd('buf', arr);
      await doCmd(type)
      console.log(`step ${step}`);
    }

    async function doUploadImage3(type='bw') {
      var ram = type=='bw'?ram_bw:ram_red;

      // grey byte to bit
      var arr = [];
      var buffer = [];
      for (var x=0; x<ram.length; x++) {
        const n = ram[x] > step ? 1 : 0;
        if (type == 'bw') {
            buffer.push(n?0:1);
        } else {
            buffer.push(n?1:0);
        }

        if (buffer.length == 8) {
          arr.push(parseInt(buffer.join(''), 2));
          buffer = [];
        }
      }
     
      info(`> write ram ${type} size ${arr.length}, step ${step}`);
      console.log(arr);
      await doCmd('buf', arr);
      await doCmd(type)
    }

    function info(logTXT) {
      var today = new Date();
      var time = ("0" + today.getHours()).slice(-2) + ":" + ("0" + today.getMinutes()).slice(-2) + ":" + ("0" + today.getSeconds()).slice(-2) + " : ";
      document.getElementById("log").innerHTML += time + logTXT + '<br>';
      console.log(time + logTXT);
      while ((document.getElementById("log").innerHTML.match(/<br>/g) || []).length > 10) {
        var logs_br_position = document.getElementById("log").innerHTML.search("<br>");
        document.getElementById("log").innerHTML = document.getElementById("log").innerHTML.substring(logs_br_position + 4);
      }
    }

    async function load_image() {
      const image_file = document.getElementById('image_file');
      if (image_file.files.length > 0) {
        const file = image_file.files[0];

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        const image = new Image();
        image.src = URL.createObjectURL(file);
        image.onload = function (event) {
          URL.revokeObjectURL(this.src);
          ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
          //convert_dithering()
        }
      }
    }

    function get_position(canvas, x, y) {
      let rect = canvas.getBoundingClientRect()
      return {
        x: x - rect.left * (canvas.width / rect.width),
        y: y - rect.top * (canvas.height / rect.height)
      }
    }

    function clear_canvas() {
      if (confirm('确认清除屏幕?')) {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function canvas2bytes(canvas, type = 'bw') {
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const arr = [];
      let buffer = [];

      for (let y = 0; y < canvas.height; y += 8) {
        for (let x = 0; x < canvas.width; x++) {
          for (let a = 0; a < 8; a++) {
            const i = (canvas.width * (y + a) + x) * 4;
            if (type !== 'red') {
              // 1 for white, 0 for black
              // black : 0, 0, 0
              buffer.push(imageData.data[i] === 0 && imageData.data[i + 1] === 0 && imageData.data[i + 2] === 0 ? 0 : 1);
            } else {
              // 1 for red, 0 for white
              buffer.push(imageData.data[i] > 0 && imageData.data[i + 1] === 0 && imageData.data[i + 2] === 0 ? 1 : 0);
            }
          }
          arr.push(parseInt(buffer.join(''), 2));
          buffer = [];
        }
      }
      return arr;
    }

    function canvas2grey8(canvas, type = 'bw') {
      // each px = 4bit black + 4bit red.
      const ctx = canvas.getContext("2d");
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const arr = [];
      let buffer = [];

      for (let y = 0; y < canvas.height; y += 8) {
        for (let x = 0; x < canvas.width; x++) {
          for (let a = 0; a < 8; a++) {
            const i = (canvas.width * (y + a) + x) * 4;
            const R = imageData.data[i];
            const G = imageData.data[i+1];
            const B = imageData.data[i+2];
            
            let grey = 0;  // white
            if (R == 255 && G != 255 && B != 255) { // red
              grey = (type == 'bw') ? 0 : (510+62-G-B)>>6;
            } else { // gray
              grey = (type == 'bw') ? (255+31-R)>>5 : 0;
            }
            arr.push(grey);
          }
        }
      }
      return arr;
    }

  </script>

  <p>
    <label> Choose </label>
    <button id="btnConnect" type="button" onclick="doConnect()">Connect</button>
  </p>
  <p id="etagFn" style="visibility:hidden;">
    <button id="btnReadEtag" type="button" onclick="doReadEtag()">ReadEtag</button>
    <button id="btnSetTime" type="button" onclick="doSetTime()">SetTime</button>
    <button id="btnRtcCollab" type="button" onclick="doRtcCollab()">RtcCollab</button>
    <button id="btnTest" type="button" onclick="doTest()">Test</button>
  </p>
  <p>
    <button type="button" onclick="doCmd('clr')">CLR</button>
    <button type="button" onclick="doCmd('mode')">MODE</button>
    <button type="button" onclick="doCmd('bw')">BW</button>
    <button type="button" onclick="doCmd('red')">RED</button>
    <button type="button" onclick="doCmd('dp')">DP</button>
  </p>
  <div id="canvas-box">
    <input type="file" id="image_file" onchange="load_image()" accept=".png,.jpg,.bmp,.webp,.gif">
    <br>
    <canvas id="canvas" width="296" height="128" style="border: black solid 1px;"></canvas>
    <br>
    <button onclick="doUploadImage('bw')">Upload</button>
    <br>
  </div>

  <p>
  <div id="log">
    CC2640R2-ETAG Webtool. <br>
  </div>
  </p>
</body>

</html>